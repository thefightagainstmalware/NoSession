
// reasoning: this diagnostic recommends that you use dynamic_cast to downcast, however this is impossible with JNI
// due to the fact that JNI classes have no virtual members. MSVC additionally recommends either dynamic_cast or static_cast
// therefore we are using static_cast to cast jobjects to jstrings
#pragma clang diagnostic push
#pragma ide diagnostic ignored "cppcoreguidelines-pro-type-static-cast-downcast"

#include <jni.h>

#include <windows.h>
#include "gq_malwarefight_nosession_win_WindowsSandbox.h"
#include "ContainerCreate.h"
#include <algorithm>

// why? JNI_TRUE and JNI_FALSE are not actually jbooleans, they are ints
jboolean jni_true = 1;
jboolean jni_false = 0;
#define BOOL_TO_JNI(x) (x) ? jni_true : jni_false

LPWSTR objectArrayToLPWSTR(JNIEnv *env, jobjectArray args) {
    static_assert(sizeof(WCHAR) == sizeof(unsigned short));

    jsize to_allocate = 1; // null terminator
    for (jsize i = 0; i < env->GetArrayLength(args); i++) {
        to_allocate += env->GetStringLength(static_cast<jstring>(env->GetObjectArrayElement(args, i)));
        to_allocate++; // space char
    }

    auto string = static_cast<LPWSTR>(malloc(sizeof(WCHAR) * to_allocate));
    ZeroMemory(&string[0], sizeof(WCHAR) * to_allocate);

    size_t index = 0;
    for (jsize i = 0; i < env->GetArrayLength(args); i++) {
        auto jstring_element = static_cast<jstring>(env->GetObjectArrayElement(args, i));
        auto chars = env->GetStringChars(jstring_element, nullptr);
        for (jsize j = 0; j < env->GetStringLength(jstring_element); j++) {
            string[index] = chars[j];
            index++;
        }
        env->ReleaseStringChars(jstring_element, chars);

        string[index] = L' ';
        index++;
    }
    return string;
}

LPWSTR* objectArrayToLPWSTRArray(JNIEnv *env, jobjectArray array) {
    auto newArray = static_cast<LPWSTR *>(malloc(sizeof(LPWSTR) * env->GetArrayLength(array)));
    ZeroMemory(&newArray[0], sizeof(LPWSTR) * env->GetArrayLength(array));
    for (jsize i = 0; i < env->GetArrayLength(array); i++) {
        auto jstring_element = static_cast<jstring>(env->GetObjectArrayElement(array, i));
        auto chars = env->GetStringChars(jstring_element, nullptr);
        newArray[i] = static_cast<LPWSTR>(malloc(sizeof(WCHAR) * env->GetStringLength(jstring_element) + sizeof(WCHAR)));
        ZeroMemory(&newArray[i][0], sizeof(WCHAR) * env->GetStringLength(jstring_element) + sizeof(WCHAR));
        for (jsize j = 0; j < env->GetStringLength(jstring_element); j++) {
            newArray[i][j] = chars[j];
        }
    }
    return newArray;
}

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class:     gq_malwarefight_nosession_win_WindowsSandbox
 * Method:    runProcess
 * Signature: ([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z
 */
JNIEXPORT jboolean JNICALL Java_gq_malwarefight_nosession_win_WindowsSandbox_runProcess
        (JNIEnv *env, jclass, jobjectArray rwMounts, jobjectArray roMounts, jobjectArray args) {
    auto lpw_args = objectArrayToLPWSTR(env, args);
    auto lpw_rwMounts = objectArrayToLPWSTRArray(env, rwMounts);
    auto lpw_roMounts = objectArrayToLPWSTRArray(env, roMounts);
    auto success = BOOL_TO_JNI(RunExecutableInContainer(lpw_args, lpw_rwMounts, lpw_roMounts, env->GetArrayLength(rwMounts),
                                                        env->GetArrayLength(roMounts)));
    free(lpw_args);
    for (jsize i = 0; i < env->GetArrayLength(rwMounts); i++) {
        free(lpw_rwMounts[i]);
    }
    free(lpw_rwMounts);
    for (jsize i = 0; i < env->GetArrayLength(roMounts); i++) {
        free(lpw_roMounts[i]);
    }
    free(lpw_roMounts);
    return success;
}

JNIEXPORT jboolean JNICALL Java_gq_malwarefight_nosession_win_WindowsSandbox_isSandboxed
        (JNIEnv *, jclass) {
    return BOOL_TO_JNI(IsInAppContainer());
}

#ifdef __cplusplus
}
#endif

#pragma clang diagnostic pop
