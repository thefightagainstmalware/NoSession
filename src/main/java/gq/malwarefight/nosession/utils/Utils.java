package gq.malwarefight.nosession.utils;

import com.google.common.annotations.Beta;
import com.google.common.collect.ForwardingMultimap;
import com.google.gson.Gson;
import com.mojang.authlib.GameProfile;
import com.mojang.authlib.exceptions.AuthenticationUnavailableException;
import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
import gq.malwarefight.nosession.relaunch.LegacyRelaunch;
import gq.malwarefight.tokenapp.Main;
import joptsimple.OptionSpec;
import net.minecraft.client.Minecraft;
import net.minecraft.launchwrapper.Launch;
import org.apache.commons.io.ByteOrderMark;
import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.SystemUtils;
import org.apache.commons.lang3.Validate;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.objectweb.asm.Opcodes;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.UUID;

public class Utils {
    private static int PORT = -1;
    private static final int BASE_PORT = 47777;

    public static void copy(InputStream i, OutputStream o) throws IOException {
        byte[] buffer = new byte[16384];
        int read;
        while ((read = i.read(buffer)) > 0) {
            o.write(buffer, 0, read);
        }
        i.close();
        o.close();
    }

    public static byte[] read(InputStream i, Character delimiter) throws IOException {
        byte[] buffer = new byte[512];
        int index = 0;
        while (true) {
            int in = i.read();
            if (in == -1 || (delimiter != null && delimiter == in)) {
                return Arrays.copyOfRange(buffer, 0, index);
            }
            if (index == buffer.length) {
                // grow the buffer
                byte[] newBuffer = new byte[buffer.length * 2];
                System.arraycopy(
                        buffer, 0, newBuffer, 0, buffer.length
                );
                buffer = newBuffer;
            }
            buffer[index] = (byte) in;
            index++;
        }
    }

    public static String readString(InputStream i, Character delimiter) throws IOException {
        return new String(read(i, delimiter), StandardCharsets.UTF_8);
    }

    public static boolean verifyServer(Socket s) throws IOException {
        String fakeServerId = UUID.randomUUID().toString().replace("-", "");
        String explanation = "This verifies that the server actually has a valid Minecraft token to comply with the EULA."
                + "Since the serverID is randomly generated, we cannot use this to login as your Minecraft account."
                + "This is similar to code in Skytils such as https://github.com/Skytils/SkytilsMod/blob/a92e75269e90f62475354acb3df9dd757c8358bd/src/main/kotlin/gg/skytils/skytilsmod/features/impl/handlers/MayorInfo.kt#L222";
        s.getOutputStream().write(("login " + fakeServerId).getBytes(StandardCharsets.UTF_8));
        try {
            GameProfile profile = Minecraft.getMinecraft().getSessionService().hasJoinedServer(Minecraft.getMinecraft().getSession().getProfile(), fakeServerId);
            return profile != null;
        } catch (AuthenticationUnavailableException e) {
            return false;
        }
    }

    public static Socket getProperSocket(UUID id) {
        System.out.println(InetAddress.getLoopbackAddress());
        if (PORT == -1) {
            Socket socket = null;
            for (int i = BASE_PORT; i < BASE_PORT + 10; i++) {
                try {
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), i));
                    socket.getOutputStream().write("uuid\n".getBytes(StandardCharsets.UTF_8));
                    String value = readString(socket.getInputStream(), '\n');
                    if (UUID.fromString(value).equals(id) && verifyServer(socket)) {
                        PORT = i;
                        break;
                    }
                } catch (Exception exception) {
                    exception.printStackTrace();
                    socket = null;
                }
            }
            return socket;
        } else {
            try {
                Socket socket = new Socket();
                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), PORT));
                if (!verifyServer(socket)) {
                    PORT = -1;
                    return getProperSocket(id);
                }
                return socket;
            } catch (IOException e) {
                PORT = -1;
                return getProperSocket(id);
            }
        }
    }

    public static String normalizeUUID(String uuid) {
        return uuid.replaceFirst(
                "(\\p{XDigit}{8})(\\p{XDigit}{4})(\\p{XDigit}{4})(\\p{XDigit}{4})(\\p{XDigit}+)", "$1-$2-$3-$4-$5"
        );
    }

    public static void setStaticValue(Class<?> cls, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field f = cls.getDeclaredField(fieldName);
        LegacyRelaunch.setModifiable(f);
        f.set(null, value);
    }

    public static String processString(String uri) {
        try {
            return uri.substring(uri.indexOf(":") + 1, uri.lastIndexOf('!'));
        } catch (Exception e) {
            e.printStackTrace();
            return uri;
        }
    }

    public static File getLibraryPathAsFile(Class<?> c) throws URISyntaxException {
        String uri = c.getProtectionDomain().getCodeSource().getLocation().toURI().toString().replace("%20", " "); // code breakage in 3, 2, 1...
        if (uri.endsWith(".class")) {
            uri = processString(uri); // stupid reference to a class within a jar
        }
        return new File(new URI(uri));
    }

    public static String getLibraryPath(Class<?> c) throws URISyntaxException {
        return getLibraryPathAsFile(c).getAbsolutePath();
    }

    private static String getClasspath() throws URISyntaxException {
        return String.join(
                System.getProperty("path.separator"),
                getLibraryPath(Main.class),
                getLibraryPath(YggdrasilAuthenticationService.class),
                getLibraryPath(Gson.class),
                getLibraryPath(LogManager.class),
                getLibraryPath(Validate.class),
                getLibraryPath(ForwardingMultimap.class),
                getLibraryPath(Beta.class),
                getLibraryPath(CharEncoding.class),
                getLibraryPath(ByteOrderMark.class),
                getLibraryPath(Logger.class),
                getLibraryPath(Opcodes.class),
                getLibraryPath(Launch.class),
                getLibraryPath(OptionSpec.class)
        );
    }

    /**
     * Gets the java exe path
     * @return the exe path
     */
    public static String getJavaExe(boolean shouldBeWindowed) {
        try {
            return Paths.get(String.join(
                System.getProperty("file.separator"),
                System.getProperty("java.home"),
                "bin",
                "java" + (shouldBeWindowed && SystemUtils.IS_OS_WINDOWS ? "w" : "") + (SystemUtils.IS_OS_WINDOWS ? ".exe" : "")
            )).toFile().getAbsolutePath();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void setToken(String token) throws IOException, URISyntaxException {
        ProcessBuilder processBuilder = new ProcessBuilder(
                getJavaExe(false), "-XX:+DisableAttachMechanism", "-cp", getClasspath(), Main.class.getName(), Launch.minecraftHome.toPath().resolve("logs/nosession_tokenapp.log").toFile().getAbsolutePath()
        );
        processBuilder.redirectOutput(ProcessBuilder.Redirect.INHERIT).redirectError(ProcessBuilder.Redirect.INHERIT);
        Process c = processBuilder.start();
        c.getOutputStream().write((token + "\n").getBytes(StandardCharsets.UTF_8));
        c.getOutputStream().flush();
        c.getOutputStream().close();
    }

    public static void shutdown() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class<?> shutdown = Class.forName("java.lang.Shutdown");
        Method m = shutdown.getDeclaredMethod("exit", int.class);
        m.setAccessible(true);
        m.invoke(null, 0);
    }

}
